BookService
package com.example.bookapp.data.api

import com.example.bookapp.data.model.BookResponse
import retrofit2.http.GET
import retrofit2.http.Query

// Retrofit API interface
interface BookService {
    @GET("volumes")
    suspend fun searchBooks(
        @Query("q") query: String,
        @Query("maxResults") maxResult: Int = 40
    ): BookResponse


}
NetworkModule
package com.example.bookapp.data.di

import com.example.bookapp.data.api.BookService
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory

//Sets up API client
object NetworkModule{

    private const val BASE_URL = "https://www.googleapis.com/books/v1/"
    // Creating Moshi instance with Kotlin adapter
    private val moshi = Moshi.Builder()
        .add(KotlinJsonAdapterFactory())
        .build()

    // Creating Retrofit instance
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(MoshiConverterFactory.create(moshi))
        .build()

    // Creating API service instance
    val bookService: BookService = retrofit.create(BookService::class.java)




}
BookDao
package com.example.bookapp.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.bookapp.data.local.entity.BookEntity
import kotlinx.coroutines.flow.Flow

// Data Access Object(DAO) -Defines database operations
@Dao
interface BookDao {
  @Query("SELECT * FROM books") fun getAllBooks(): Flow<List<BookEntity>>

  @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insertBook(book: BookEntity)
}
BookDatabase
package com.example.bookapp.data.local

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import com.example.bookapp.data.local.dao.BookDao
import com.example.bookapp.data.local.entity.BookEntity

// Main database class
@Database(entities = [BookEntity::class], version = 1, exportSchema = true)
abstract class BookDatabase : RoomDatabase() {
  abstract fun bookDao(): BookDao

  companion object {
    @Volatile private var INSTANCE: BookDatabase? = null

    fun getDatabase(context: Context): BookDatabase {
      return INSTANCE
          ?: synchronized(this) {
            val instance =
                Room.databaseBuilder(
                        context.applicationContext, BookDatabase::class.java, "book_database")
                    .build()
            INSTANCE = instance
            instance
          }
    }
  }
}
BookResponse.kt
package com.example.bookapp.data.model
import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

@JsonClass(generateAdapter = true)
data class BookResponse(
    @Json(name = "items") val items: List<BookItem>? = null
)

@JsonClass(generateAdapter = true)
data class BookItem(
    @Json(name = "id") val id: String? = null,
    @Json(name = "volumeInfo") val volumeInfo: VolumeInfo? = null
)

@JsonClass(generateAdapter = true)
data class VolumeInfo(
    @Json(name = "title") val title: String? = null,
    @Json(name = "authors") val authors: List<String>? = null,
    @Json(name = "description") val description: String? = null,
    @Json(name = "imageLinks") val imageLinks: ImageLinks? = null,
    // ADDED: New fields
    @Json(name = "publishedDate") val publishedDate: String? = null,
    @Json(name = "pageCount") val pageCount: Int? = null,
    @Json(name = "categories") val categories: List<String>? = null
)

@JsonClass(generateAdapter = true)
data class ImageLinks(
    @Json(name = "thumbnail") val thumbnail: String? = null
)
BookRepository
package com.example.bookapp.data.repository

import com.example.bookapp.data.api.BookService
import com.example.bookapp.data.local.dao.BookDao
import com.example.bookapp.data.local.entity.toBook
import com.example.bookapp.data.local.entity.toBookEntity
import com.example.bookapp.domain.model.Book
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

// Connects database and network operations

class BookRepository(private val bookService: BookService, private val bookDao: BookDao) {
  // Network operation - Get books from API
  suspend fun searchBooks(query: String): List<Book> {
    return try {
      val response = bookService.searchBooks(query)
      response.items?.map { bookItem ->
        val volumeInfo = bookItem.volumeInfo
        Book(
            id = bookItem.id ?: "",
            title = volumeInfo?.title ?: "Unknown Title",
            author = volumeInfo?.authors?.firstOrNull() ?: "Unknown Author",
            description = volumeInfo?.description ?: "No description available",
            thumbnailUrl = volumeInfo?.imageLinks?.thumbnail ?: "",
            publishedDate = volumeInfo?.publishedDate ?: "Unknown date",
            pageCount = volumeInfo?.pageCount ?: 0,
            categories = volumeInfo?.categories ?: emptyList())
      } ?: emptyList()
    } catch (e: Exception) {
      emptyList()
    }
  }

  // Database operations
  fun getSavedBooks(): Flow<List<Book>> {
    return bookDao.getAllBooks().map { entities -> entities.map { it.toBook() } }
  }

  suspend fun saveBook(book: Book) {
    bookDao.insertBook(book.toBookEntity())
  }
}
Book
package com.example.bookapp.domain.model
// Initial book model
data class Book(
    val id: String = "",
    val title: String,
    val author: String,
    val description: String = "",
    val thumbnailUrl: String = "",
    val publishedDate: String = "",
    val pageCount: Int = 0,
    val categories: List<String> = emptyList()
)
BookDetailScreen.kt
package com.example.bookapp.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.bookapp.domain.model.Book

// Book detail screen
@Composable
fun BookDetailScreen(
    book: Book,
    onBackClick: () -> Unit,
    onSaveClick: (Book) -> Unit = {} // Add this parameter
) {
  Column(modifier = Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(16.dp)) {
    // Buttons row
    Row(
        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),
        horizontalArrangement = Arrangement.SpaceBetween) {
          Button(onClick = onBackClick) { Text("Back to Search") }

          Button(onClick = { onSaveClick(book) }) { Text("Save Book") }
        }

    // temporary Text to verify ID
    Text(
        text = "Book ID: ${book.id}",
        style = MaterialTheme.typography.bodySmall,
        modifier = Modifier.padding(bottom = 8.dp))

    // Book details
    Text(
        text = book.title,
        style = MaterialTheme.typography.headlineMedium,
        modifier = Modifier.padding(bottom = 8.dp))

    Text(
        text = "By ${book.author}",
        style = MaterialTheme.typography.titleMedium,
        modifier = Modifier.padding(bottom = 16.dp))

    if (book.publishedDate.isNotBlank()) {
      Text(
          text = "Published: ${book.publishedDate}",
          style = MaterialTheme.typography.bodyMedium,
          modifier = Modifier.padding(bottom = 8.dp))
    }

    if (book.pageCount > 0) {
      Text(
          text = "Pages: ${book.pageCount}",
          style = MaterialTheme.typography.bodyMedium,
          modifier = Modifier.padding(bottom = 8.dp))
    }

    if (book.categories.isNotEmpty()) {
      Text(
          text = "Categories:",
          style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Bold),
          modifier = Modifier.padding(bottom = 4.dp))
      book.categories.forEach { category ->
        Text(
            text = "â€¢ $category",
            style = MaterialTheme.typography.bodyMedium,
            modifier = Modifier.padding(start = 8.dp, bottom = 2.dp))
      }
    }

    Spacer(modifier = Modifier.height(16.dp))

    if (book.description.isNotBlank()) {
      Text(
          text = "Description:",
          style = MaterialTheme.typography.titleMedium,
          modifier = Modifier.padding(bottom = 8.dp))
      Text(text = book.description, style = MaterialTheme.typography.bodyMedium)
    }
  }
}
BookSearchScreen.kt
package com.example.bookapp.ui.screens

import android.app.Application
import android.widget.Toast
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.bookapp.domain.model.Book

// Main search screen with saved books toggle

@Composable
fun BookSearchScreen() {
  val context = LocalContext.current
  val viewModel: BookSearchViewModel =
      viewModel(
          factory =
              object : ViewModelProvider.Factory {
                override fun <T : ViewModel> create(modelClass: Class<T>): T {
                  if (modelClass.isAssignableFrom(BookSearchViewModel::class.java)) {
                    return BookSearchViewModel(context.applicationContext as Application) as T
                  }
                  throw IllegalArgumentException("Unknown ViewModel class")
                }
              })

  val state by viewModel.state.collectAsState()
  val savedBooks by viewModel.savedBooks.collectAsState()

  // Show toast when message changes
  LaunchedEffect(state.message) {
    state.message?.let { message ->
      Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
      viewModel.clearMessage()
    }
  }

  // Handle book detail navigation
  state.selectedBook?.let { book ->
    BookDetailScreen(
        book = book, onBackClick = viewModel::onBackClick, onSaveClick = viewModel::saveBook)
    return
  }

  Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
    // Toggle between search and saved books
    Button(
        onClick = viewModel::toggleSavedBooks,
        modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp)) {
          Text(if (state.isShowingSavedBooks) "Show Search" else "Show Saved Books")
        }

    if (state.isShowingSavedBooks) {
      // Saved books list
      LazyColumn(modifier = Modifier.fillMaxWidth().padding(top = 16.dp)) {
        items(savedBooks) { book ->
          BookItem(book = book, onClick = { viewModel.onBookClick(book) })
        }
      }
    } else {
      // Show search interface and results
      TextField(
          value = state.searchQuery,
          onValueChange = viewModel::onSearchQueryChange,
          label = { Text("Search for books") },
          placeholder = { Text("Enter book title") },
          modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp))

      Button(onClick = viewModel::onSearchClick, modifier = Modifier.fillMaxWidth()) {
        Text("Search")
      }

      LazyColumn(modifier = Modifier.fillMaxWidth().padding(top = 16.dp)) {
        items(state.books) { book ->
          BookItem(book = book, onClick = { viewModel.onBookClick(book) })
        }
      }
    }
  }
}

@Composable
fun BookItem(book: Book, onClick: () -> Unit) {
  Card(modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp).clickable(onClick = onClick)) {
    Column(modifier = Modifier.padding(16.dp)) {
      Text(text = book.title, style = MaterialTheme.typography.titleMedium)
      Text(text = "By ${book.author}", style = MaterialTheme.typography.bodyMedium)
    }
  }
}
BookSearchViewModel
// ui/screens/BookSearchViewModel.kt
package com.example.bookapp.ui.screens

import android.app.Application
import androidx.lifecycle.AndroidViewModel  // Change this import
import androidx.lifecycle.viewModelScope
import com.example.bookapp.data.di.NetworkModule
import com.example.bookapp.data.local.BookDatabase
import com.example.bookapp.data.repository.BookRepository
import com.example.bookapp.domain.model.Book
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class BookSearchViewModel(application: Application) : AndroidViewModel(application) {  // Change this line
    private val database = BookDatabase.getDatabase(getApplication())
    private val repository = BookRepository(
        bookService = NetworkModule.bookService,
        bookDao = database.bookDao()
    )

    private val _state = MutableStateFlow(SearchState())
    val state: StateFlow<SearchState> = _state.asStateFlow()

    fun onSearchQueryChange(query: String) {
        _state.value = _state.value.copy(searchQuery = query)
    }

    fun onSearchClick() {
        val currentQuery = state.value.searchQuery
        if (currentQuery.isBlank()) return

        viewModelScope.launch {
            try {
                val books = repository.searchBooks(currentQuery)
                _state.value = _state.value.copy(books = books)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun onBookClick(book: Book) {
        _state.value = _state.value.copy(selectedBook = book)
    }

    fun onBackClick() {
        _state.value = _state.value.copy(selectedBook = null)
    }

    // Add new function to save book
    fun clearMessage() {
        _state.value = _state.value.copy(message = null)
    }

    fun saveBook(book: Book) {
        viewModelScope.launch {
            try {
                repository.saveBook(book)
                _state.value = _state.value.copy(message = "Book saved successfully!")
            } catch (e: Exception) {
                _state.value = _state.value.copy(message = "Error saving book: ${e.message}")
                e.printStackTrace()
            }
        }
    }
    val savedBooks: StateFlow<List<Book>> = repository.getSavedBooks()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    // Add this function
    fun toggleSavedBooks() {
        _state.value = _state.value.copy(
            isShowingSavedBooks = !state.value.isShowingSavedBooks
        )
    }
}
SearchState
package com.example.bookapp.ui.screens

import android.app.DownloadManager.Query
import com.example.bookapp.domain.model.Book

data class SearchState(
    val searchQuery: String = "",
    val books: List<Book> = emptyList(),
    val selectedBook: Book? = null,
    val message: String? = null,
    val isShowingSavedBooks: Boolean = false

)
MainActivity.kt
package com.example.bookapp

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.runtime.Composable
import com.example.bookapp.ui.screens.BookSearchScreen
import com.example.bookapp.ui.theme.BookAppTheme

// Entry point of the app, contain basic app setup and navigation

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            BookAppTheme {
                MainScreen()
            }
        }
    }
}

@Composable
fun MainScreen() {
    BookSearchScreen()
}
ExampleUnitTest
NOTHING YET

build.gradle.kts
// App-specific  build configuration

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.ksp)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.room)
}

android {
    namespace = "com.example.bookapp"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.bookapp"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.8"
    }
}
room {
    schemaDirectory("$projectDir/schemas")
}
dependencies {
    // Existing dependencies
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)

    // Add these new dependencies
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.lifecycle.runtime.compose)

    // Testing dependencies
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.lifecycle.runtime.compose)

    // Retrofit
    implementation(libs.retrofit.core)
    implementation(libs.retrofit.moshi)
    implementation(libs.moshi.kotlin)


    // Room
    implementation(libs.androidx.room.runtime)
    implementation(libs.androidx.room.ktx)
    ksp(libs.androidx.room.compiler)
}
build.gradle.kts
// project-level build configuration, plugin versions, repository configurations

plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.compose.compiler) apply false
}
libs.versions.toml
[versions]
agp = "8.7.2"
kotlin = "2.0.21"
coreKtx = "1.15.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.8.7"
activityCompose = "1.9.3"
composeBom = "2024.11.00"
lifecycle = "2.8.7"
retrofit = "2.11.0"
moshiKotlin = "1.15.1"
room-gradle = "2.6.1"
room = "2.6.1"
ksp = "2.0.21-1.0.27"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }

# new libraries
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycle" }
androidx-lifecycle-runtime-compose = { group = "androidx.lifecycle", name = "lifecycle-runtime-compose", version.ref = "lifecycle" }

# Retrofit
retrofit-core = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
retrofit-moshi = { group = "com.squareup.retrofit2", name = "converter-moshi", version.ref = "retrofit" }
moshi-kotlin = { group = "com.squareup.moshi", name = "moshi-kotlin", version.ref = "moshiKotlin" }

# Room
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "room" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "room" }
[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
room = { id = "androidx.room", version.ref = "room-gradle" }

settings.gradle.kts
pluginManagement {
  repositories {
    gradlePluginPortal()
    google()
    mavenCentral()
  }
  resolutionStrategy {
    eachPlugin {
      if (requested.id.id == "com.google.devtools.ksp") {
        useModule("com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:2.0.21-1.0.27")
      }
    }
  }
}

dependencyResolutionManagement {
  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
  repositories {
    google()
    mavenCentral()
  }
}

rootProject.name = "BookApp"
include(":app")

gradle-wrapper.properties
#Mon Nov 04 11:25:32 GMT 2024
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
